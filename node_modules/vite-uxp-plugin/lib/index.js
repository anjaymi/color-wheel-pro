"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runAction = exports.uxp = exports.uxpSetup = void 0;
const os = require("os");
const child_process_1 = require("child_process");
const hot_reload_1 = require("./hot-reload");
const cxx_1 = require("./cxx");
const polyfill_1 = require("./polyfill");
const fs_1 = require("fs");
const path = require("path");
const plugin_utils_1 = require("meta-bolt/dist/plugin-utils");
const utils_1 = require("meta-bolt/dist/utils");
const lib_1 = require("meta-bolt/dist/lib");
const uxpSetup = (config, mode) => {
    if (mode === "dev") {
        (0, hot_reload_1.hotReloadServer)(config.hotReloadPort);
    }
};
exports.uxpSetup = uxpSetup;
const deleteExistingBinaries = (config) => {
    try {
        const dist = path.join(process.cwd(), "dist");
        const win = path.join(dist, "win");
        const mac = path.join(dist, "mac");
        const win64 = path.join(win, "x64");
        const winArm64 = path.join(win, "arm64");
        const mac64 = path.join(mac, "x64");
        const macArm64 = path.join(mac, "arm64");
        let paths = [];
        [win64, winArm64, mac64, macArm64].map((dir) => {
            if ((0, fs_1.existsSync)(dir) === false)
                return;
            (0, fs_1.readdirSync)(dir).map((file) => {
                const fullPath = path.join(dir, file);
                paths.push(fullPath);
                (0, fs_1.unlinkSync)(fullPath);
            });
        });
        console.log("Deleted Binaries: ", paths.join(", "));
    }
    catch (e) {
        console.warn("UXP Hybrid Binaries were not updated. Ensure plugin is unloaded from UDT before rebuilding as binaries are locked during debug.");
    }
};
const copyFileChanges = (src, dest) => {
    let copiedFiles = [];
    const srcFiles = (0, fs_1.readdirSync)(src);
    srcFiles.map((file) => {
        const srcPath = path.join(src, file);
        const destPath = path.join(dest, file);
        // if (existsSync(path.dirname(destPath)) === false) {
        //   mkdirSync(destPath, { recursive: true });
        // }
        const srcStat = (0, fs_1.statSync)(srcPath);
        if (srcStat.isDirectory()) {
            if ((0, fs_1.existsSync)(destPath) === false) {
                console.log("mkdir ::: ", destPath);
                (0, fs_1.mkdirSync)(destPath, { recursive: true });
            }
            const res = copyFileChanges(srcPath, destPath);
            copiedFiles = [...copiedFiles, ...res];
        }
        else {
            const destStat = (0, fs_1.statSync)(destPath);
            if (srcStat.size !== destStat.size) {
                copiedFiles.push(destPath);
                (0, fs_1.copyFileSync)(srcPath, destPath);
            }
        }
    });
    return copiedFiles;
};
const copyHybridBinaries = (config, onlyChanged) => {
    try {
        const dist = path.join(process.cwd(), "dist");
        const hybridPublic = path.join(process.cwd(), "public-hybrid");
        if ((0, fs_1.existsSync)(hybridPublic) === false)
            return;
        if (onlyChanged) {
            const changedFiles = copyFileChanges(hybridPublic, dist);
            if (changedFiles.length > 0) {
                console.log(`copied ${changedFiles.length} changed binary files`, changedFiles);
            }
        }
        else {
            (0, fs_1.readdirSync)(hybridPublic).map((file) => {
                // console.log(
                //   "copy",
                //   path.join(hybridPublic, file),
                //   "TO",
                //   path.join(dist, file)
                // );
                (0, fs_1.cpSync)(path.join(hybridPublic, file), path.join(dist, file), {
                    recursive: true,
                });
            });
        }
    }
    catch (e) {
        console.error(e);
        console.warn("â›” WARNING: UXP Hybrid Binaries have changed, but could not be updated. " +
            "Ensure plugin is unloaded from UDT before rebuilding as binaries are locked during debug.");
    }
};
const generateManifest = (config) => {
    const str = JSON.stringify(config.manifest, null, "\t");
    return {
        type: "asset",
        source: str,
        name: "UXP Manifest",
        fileName: "manifest.json",
    };
};
const uxp = (config, mode) => {
    return {
        name: "vite-uxp-plugin",
        //* We can't delete exisitng binaries yet because they're actively being read by UXP dev tool
        //* If we can in the future, then we can re-enable this and avoid having to manually Unload
        //* the plugin in UDT. Tracking issue here: https://github.com/hyperbrew/bolt-uxp/issues/3
        // configResolved(resolvedConfig) {
        // if (mode === "dev" && config.manifest.addon) {
        //   deleteExistingBinaries(config);
        // }
        // },
        buildStart() {
            (0, exports.uxpSetup)(config, mode);
            if (mode === "dev" && config.manifest.addon) {
                copyHybridBinaries(config, true);
            }
            if (config.webviewUi) {
                console.log("ðŸŒ Webview UI is enabled");
                const pm = (0, utils_1.getPackageManager)() || "npm";
                if (!(0, fs_1.existsSync)("./webview-ui/node_modules")) {
                    console.warn("ðŸ›‘ WEBVIEW MODULES NOT INSTALLED!");
                    console.warn("ðŸ‘‰ Install the dependencies in webview-ui with");
                    console.warn(`  cd webview-ui && ${pm} install`);
                    console.warn(`Then you can run build / dev again in the main directory`);
                    process.exit(0);
                }
                if (mode === "dev") {
                    if (pm === "npm") {
                        (0, utils_1.execAsync)(`cd webview-ui && ${pm} run dev -- --port ${config.webviewReloadPort}`);
                    }
                    else {
                        (0, utils_1.execAsync)(`cd webview-ui && ${pm} run dev --port ${config.webviewReloadPort}`);
                    }
                }
                else {
                    (0, child_process_1.execSync)(`cd webview-ui && ${pm} run build`);
                    config.manifest.entrypoints.map((entryPoint) => {
                        const name = entryPoint.id.split(".").pop();
                        (0, fs_1.copyFileSync)("public/webview-ui/index.html", `public/webview-ui/${name}.html`);
                    });
                }
            }
        },
        transform(code, id, options) {
            // console.log("id", id);
        },
        transformIndexHtml(html) {
            return html.replace('<script type="module" crossorigin', "<script");
        },
        generateBundle(output, bundle) {
            Object.keys(bundle)
                .filter((file) => file.indexOf(".js") > 0)
                .map((file) => {
                const current = bundle[file];
                current.code = polyfill_1.polyfills + "\n" + current.code;
                console.log("file", file);
                if (mode === "dev" && file.indexOf("index") > 0) {
                    // Add WS Snippet
                    current.code = (0, polyfill_1.wsListener)(config) + "\n" + current.code;
                }
            });
            //@ts-ignore
            this.emitFile(generateManifest(config));
            (0, hot_reload_1.wsUpdate)(config.manifest.id);
            return;
        },
        closeBundle() {
            return __awaiter(this, void 0, void 0, function* () {
                if (mode !== "dev" && config.manifest.addon) {
                    copyHybridBinaries(config, false);
                }
                if (mode === "package" || mode === "zip") {
                    yield (0, cxx_1.generateCCX)(config);
                }
                if (mode === "zip") {
                    const zipDir = path.join(process.cwd(), "zip");
                    const ccxDir = path.join(process.cwd(), "ccx");
                    const name = `${config.manifest.name}_${config.manifest.version}`;
                    yield (0, plugin_utils_1.zipPackage)(name, zipDir, ccxDir, config.copyZipAssets, false);
                }
            });
        },
    };
};
exports.uxp = uxp;
const upiaMac = "/Library/Application Support/Adobe/Adobe Desktop Common/RemoteComponents/UPI/UnifiedPluginInstallerAgent/UnifiedPluginInstallerAgent.app/Contents/MacOS/UnifiedPluginInstallerAgent";
const upiaWin = "C:/Program Files/Common Files/Adobe/Adobe Desktop Common/RemoteComponents/UPI/UnifiedPluginInstallerAgent/UnifiedPluginInstallerAgent.exe";
const upiaPath = os.platform() === "darwin" ? upiaMac : upiaWin;
const runAction = (config, action) => {
    const outPath = process.cwd() + "/dist";
    console.log("outPath", outPath);
    if (action === "ccx-install") {
        //* Install a CCX Plugin Package
        console.log("install");
        const res = (0, child_process_1.execSync)(`"${upiaPath}" /install "${outPath}"`, {
            encoding: "utf-8",
        });
        console.log("res", res);
    }
    else if (action === "ccx-uninstall") {
        //* Uninstall a CCX Plugin Package
        const res = (0, child_process_1.execSync)(`"${upiaPath}" /remove "${outPath}"`, {
            encoding: "utf-8",
        });
        console.log("res", res);
    }
    else if (action === "dependencyCheck") {
        (0, plugin_utils_1.packageSync)();
    }
    else {
        console.warn(`Unknown Action: ${action}`);
    }
    (0, lib_1.resetLog)();
    process.exit();
};
exports.runAction = runAction;
