"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildBolt = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const picocolors_1 = __importDefault(require("picocolors"));
const utils_1 = require("./utils");
const prompts_1 = require("@clack/prompts");
const radash_1 = require("radash");
const multiBlankLineRegex = /(\r?\n\s*){1,}/g;
const getJSRangeRegex = (variable) => new RegExp(`\/\/ BOLT_${variable}_START[\\s\\S]*?\/\/ BOLT_${variable}_END.*(\n|\r\n)?`, "gm");
const getJSOnlyRegex = (variable) => new RegExp(`^.*\/\/ BOLT_${variable}_ONLY.*(\n|\r\n)?`, "gm");
const getJSReplaceRegex = (variable) => new RegExp(`^.*\/\/ BOLT_${variable}_REPLACE.*(\n|\r\n)?`, "gm");
const allInlineCommentsRegex = /\/\/ BOLT_.*_(ONLY|REPLACE)/gm;
const allReturnCommentsRegex = /^.*\/\/ BOLT_.*_(START|END).*(\n|\r\n)?/gm;
const getJSXRegex = (variable) => new RegExp(`\\{\\/\\* BOLT_${variable}_START \\*\\/\\}([\\s\\S]*?)\\{\\/\\* BOLT_${variable}_END \\*\\/\\}.*`, "gm");
const allReturnJSXCommentsRegex = /^.*\{\/\* BOLT_.*_(START|END) \*\/\}.*(\n|\r\n)?/gm;
const allInlineJSXCommentsRegex = /\{\/\* BOLT_.*_(ONLY|REPLACE) \*\/\}/gm;
const getHTMLRegex = (variable) => new RegExp(`<!-- BOLT_${variable}_START -->[\\s\\S]*?<!-- BOLT_${variable}_END -->.*`, "g");
const allReturnHTMLCommentsRegex = /^.*<!-- BOLT_.*_(START|END).*-->.*(\n|\r\n)?/gm;
const allInlineHTMLCommentsRegex = /<!-- BOLT_.*_(ONLY|REPLACE).*-->/gm;
const htmlDisabledScriptTagRegexStart = /<!-- <script/g;
const htmlDisabledScriptTagRegexEnd = /<\/script> -->.*/g;
const replaceAll = (txt, variable, replace) => {
    const rangeRegexJS = getJSRangeRegex(variable);
    const onlyRegexJS = getJSOnlyRegex(variable);
    const rangeRegexHTML = getHTMLRegex(variable);
    const onlyRegexHTML = getHTMLRegex(variable);
    const rangeRegexJSX = getJSXRegex(variable);
    txt = txt
        .replace(rangeRegexJS, replace)
        .replace(onlyRegexJS, replace)
        .replace(rangeRegexHTML, replace)
        .replace(onlyRegexHTML, replace)
        .replace(rangeRegexJSX, replace);
    return txt;
};
const formatFile = async (txt, ext, keywordsIncludes, keywordsExcludes, args) => {
    // remove excluded keywords
    keywordsExcludes.map((keyword) => {
        const upper = keyword.toUpperCase();
        txt = replaceAll(txt, upper, "");
    });
    // inject replace values
    Object.keys(args).map((key) => {
        const value = args[key];
        const upper = key.toUpperCase();
        const rangeReplaceJS = getJSReplaceRegex(upper);
        const matches = txt.match(rangeReplaceJS);
        if (matches) {
            matches.map((match) => {
                const stringRegex = /(["'])((?:\\\1|(?:(?!\1)).)*)(\1)/g;
                const oldStringMatches = match.match(stringRegex);
                if (oldStringMatches) {
                    const i = oldStringMatches.length - 1;
                    const oldString = oldStringMatches[i];
                    const quotation = oldString[0];
                    const newString = `${quotation}${value}${quotation}`;
                    const newMatch = match.replace(oldString, newString);
                    txt = txt.replace(match, newMatch);
                }
            });
        }
    });
    // cleanup all remaining bolt comments
    [
        allInlineCommentsRegex,
        allReturnCommentsRegex,
        allReturnJSXCommentsRegex,
        allInlineJSXCommentsRegex,
        allReturnHTMLCommentsRegex,
        allInlineHTMLCommentsRegex,
    ].map((regex) => {
        txt = txt.replace(regex, "");
    });
    if (ext === ".html") {
        // re-enable all disabled <script /> tags
        txt = txt
            .replace(htmlDisabledScriptTagRegexStart, "<script")
            .replace(htmlDisabledScriptTagRegexEnd, "</script>");
    }
    //   txt = await prettier.format(txt, {
    //     parser: "typescript",
    //   });
    return txt;
};
const buildBolt = async (intro, initData, base, args) => {
    if (!args.folder || typeof args.folder !== "string")
        throw Error("Folder not provided");
    if (!args.framework || typeof args.folder !== "string")
        throw Error("Framework not provided");
    const fullPath = path_1.default.join(args.folder);
    (0, prompts_1.note)(`Creating ${intro.prettyName} in ${picocolors_1.default.green(picocolors_1.default.bold(fullPath))}`, "Info");
    const localStem = (0, utils_1.posix)(path_1.default.join(base.createDirName, "..", `/node_modules/${base.module}/`));
    const globalStem = (0, utils_1.posix)(path_1.default.join(base.createDirName, `../../${base.module}`));
    // console.log({
    //   createDirName: base.createDirName,
    //   localStem,
    //   globalStem,
    // });
    const stem = fs_1.default.existsSync(globalStem) ? globalStem : localStem;
    if (fs_1.default.existsSync(fullPath))
        fs_1.default.rmSync(fullPath, { recursive: true });
    fs_1.default.mkdirSync(fullPath, { recursive: true });
    let fileIncludes = [...base.globalIncludes];
    let fileExcludes = [...base.globalExcludes];
    let keywordIncludes = [];
    let keywordExcludes = [];
    initData.argsTemplate.map((argTmp) => {
        if (argTmp.type === "select" || argTmp.type === "multiselect") {
            argTmp.options.map((opt) => {
                const selected = args[argTmp.name];
                const current = opt.value.toLowerCase();
                if ((typeof selected === "string" && selected === current) ||
                    ((0, radash_1.isArray)(selected) && selected.includes(current))) {
                    fileIncludes = [...fileIncludes, ...opt.files];
                    keywordIncludes = [...keywordIncludes, opt.value.toUpperCase()];
                }
                else {
                    fileExcludes = [...fileExcludes, ...opt.files];
                    keywordExcludes = [...keywordExcludes, opt.value.toUpperCase()];
                }
            });
        }
        if (argTmp.type === "boolean") {
            const argName = argTmp.name;
            const argNameUpper = argName.toUpperCase();
            const value = args[argName];
            if (value) {
                keywordIncludes = [...keywordIncludes, argNameUpper];
            }
            else {
                keywordExcludes = [...keywordExcludes, argNameUpper];
            }
            if (argTmp.options) {
                const trueOpt = argTmp.options.find((o) => o.value === "true");
                const fasleOpt = argTmp.options.find((o) => o.value === "false");
                if (trueOpt && fasleOpt) {
                    if (value) {
                        fileIncludes = [...fileIncludes, ...trueOpt.files];
                        fileExcludes = [...fileExcludes, ...fasleOpt.files];
                    }
                    else {
                        fileIncludes = [...fileIncludes, ...fasleOpt.files];
                        fileExcludes = [...fileExcludes, ...trueOpt.files];
                    }
                }
            }
        }
    });
    // console.log({
    //   fileIncludes,
    //   fileExcludes,
    //   keywordIncludes,
    //   keywordExcludes,
    // });
    const files = await (0, fast_glob_1.default)([
        ...fileIncludes.map((i) => (0, utils_1.posix)(path_1.default.join(stem, i))),
        ...fileExcludes.map((i) => `!` + (0, utils_1.posix)(path_1.default.join(stem, i))),
    ], {
        onlyFiles: true,
        followSymbolicLinks: true,
        dot: true,
    });
    // console.log({ files });
    for (const file of files) {
        const fileName = file.replace(stem, "");
        const dest = path_1.default.join(fullPath, fileName);
        const parent = path_1.default.dirname(dest);
        if (!fs_1.default.existsSync(parent))
            fs_1.default.mkdirSync(parent, { recursive: true });
        if (fs_1.default.statSync(file).isDirectory()) {
            fs_1.default.cpSync(file, dest, {
                recursive: true,
            });
        }
        else {
            fs_1.default.copyFileSync(file, dest);
            const txt = fs_1.default.readFileSync(dest, "utf8");
            const ext = path_1.default.extname(dest);
            const newTxt = await formatFile(txt, ext, keywordIncludes, keywordExcludes, args);
            // wite file if changed
            if (newTxt !== txt) {
                args.verbose &&
                    console.log(`UPDATING CHANGED: ${picocolors_1.default.green(picocolors_1.default.bold(fileName))}`);
                fs_1.default.writeFileSync(dest, newTxt, "utf8");
            }
        }
    }
    //* Handle Renames
    initData.base.fileRenames?.map(([oldName, newName]) => {
        const oldPath = path_1.default.join(fullPath, oldName);
        if (!fs_1.default.existsSync(oldPath))
            return;
        const newPath = path_1.default.join(fullPath, newName);
        fs_1.default.renameSync(oldPath, newPath);
    });
    const pm = (0, utils_1.getPackageManager)() || "npm";
    // * Dependencies
    if (args.installDeps) {
        const s = (0, prompts_1.spinner)();
        s.start("Installing dependencies...");
        await (0, utils_1.execAsync)(`cd "${fullPath}" && ${pm} install`);
        s.stop("Dependencies installed!");
    }
    const maxArgNameLength = Math.max(...initData.argsTemplate.map((argTmp) => argTmp.name.length));
    const noteStr = Object.keys(args).map((key) => {
        const value = args[key];
        return `${key.padEnd(maxArgNameLength + 3, " ")} ${value.toString()}`;
    });
    (0, prompts_1.note)(noteStr.join("\n"), "Inputs");
    let summary = [
        `${intro.prettyName} generated` + `: ${picocolors_1.default.green(picocolors_1.default.bold(fullPath))}.`,
        `To get started, run: ${picocolors_1.default.yellow(`cd ${path_1.default.basename(fullPath)} && ${pm} run build`)} and see the README for more help.`,
    ];
    if (!args.installDeps) {
        summary = [
            ...summary,
            "",
            `Dependencies not installed. To install, run: ${picocolors_1.default.yellow(`cd ${path_1.default.basename(fullPath)} && ${pm} install`)}`,
        ];
    }
    (0, prompts_1.note)(summary.join("\n"), "Summary");
    return fullPath;
};
exports.buildBolt = buildBolt;
