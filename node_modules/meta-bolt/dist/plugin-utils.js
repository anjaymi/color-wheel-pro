"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.copyFilesRecursively = exports.emptyFolder = exports.packageSync = exports.zipPackage = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const zip_1 = require("./zip");
Object.defineProperty(exports, "zipPackage", { enumerable: true, get: function () { return zip_1.zipPackage; } });
const jsonc_parser_1 = require("jsonc-parser");
const versionOnly = (str) => str.match(/[0-9]+\.[0-9]+\.[0-9]+/)?.shift() || "";
const packageSync = () => {
    const basePath = "./"; // Modify this path if your package files are in a different directory
    const packageFiles = (0, fs_1.readdirSync)(basePath).filter((file) => file.match(/^package\..*\.json(c?)$/));
    const pack = (0, fs_1.readFileSync)((0, path_1.join)(basePath, "package.json"), "utf-8");
    const packJson = JSON.parse(pack);
    const warnings = {};
    packageFiles.forEach((file) => {
        let content = (0, fs_1.readFileSync)((0, path_1.join)(basePath, file), "utf-8");
        const jsonData = file.endsWith(".jsonc")
            ? (content = (0, jsonc_parser_1.parse)(content))
            : JSON.parse(content);
        const jsonContent = jsonData;
        const framework = file.split(".")[1];
        warnings[framework] = [];
        Object.keys(packJson.dependencies).forEach((dep) => {
            const version = packJson.dependencies[dep];
            const frameworkVersion = jsonContent.dependencies?.[dep];
            if (frameworkVersion && frameworkVersion !== version) {
                warnings[framework].push(`${framework}: ${dep} ${frameworkVersion} -> ${version}`);
            }
        });
        Object.keys(packJson.devDependencies).forEach((dep) => {
            const version = packJson.devDependencies[dep];
            const frameworkVersion = jsonContent.devDependencies?.[dep];
            if (frameworkVersion && frameworkVersion !== version) {
                warnings[framework].push(`${framework} (devDependencies): ${dep} ${frameworkVersion} -> ${version}`);
            }
        });
    });
    console.log("\nFramework Package JSON Comparisons");
    Object.keys(warnings).forEach((framework) => {
        console.log(`- ${framework.charAt(0).toUpperCase() + framework.slice(1)} Warnings`, warnings[framework]);
    });
    // Verify updated package.json versions
    console.log("\nVerify Repo Versions Updated");
    const pluginDir = (0, fs_1.readdirSync)(basePath).find((name) => name.startsWith("vite-") &&
        name.endsWith("-plugin") &&
        (0, fs_1.lstatSync)((0, path_1.join)(basePath, name)).isDirectory()) || "";
    const pluginPack = (0, fs_1.readFileSync)((0, path_1.join)(pluginDir, "package.json"), "utf-8");
    const pluginPackJson = JSON.parse(pluginPack);
    const createScriptDir = (0, fs_1.readdirSync)(basePath).find((name) => name.startsWith("create-bolt-") &&
        (0, fs_1.lstatSync)((0, path_1.join)(basePath, name)).isDirectory()) || "";
    const createScriptPack = (0, fs_1.readFileSync)((0, path_1.join)(createScriptDir, "package.json"), "utf-8");
    const createScriptPackJson = JSON.parse(createScriptPack);
    const rootDir = (0, path_1.basename)((0, path_1.resolve)("."));
    const pluginVersion = pluginPackJson.version;
    const rootVersion = packJson.version;
    const rootDepPlugin = packJson.devDependencies[pluginDir];
    const rootDepPluginMatches = versionOnly(rootDepPlugin) === pluginVersion;
    const createScriptVersion = createScriptPackJson.version;
    const createDepRoot = createScriptPackJson.dependencies[rootDir];
    const createDepRootMatches = versionOnly(createDepRoot) === rootVersion;
    console.log("- ", pluginDir, pluginVersion);
    console.log("- ", rootDir, rootVersion);
    console.log(`  - ${pluginDir} version: ${rootDepPlugin} ${rootDepPluginMatches ? "✅" : `❌ Update to ${pluginVersion}`}`);
    console.log("- ", createScriptDir, createScriptVersion);
    console.log(`  - ${rootDir} version: ${createDepRoot} ${createDepRootMatches ? "✅" : `❌ Update to ${rootVersion}`}`);
    // TODO Test
    console.log("\nChangelog Update Check");
    const changelogPath = (0, path_1.join)(basePath, "CHANGELOG.md");
    if (!(0, fs_1.existsSync)(changelogPath)) {
        console.warn("- CHANGELOG.md not found. Please create or update it. ❌");
    }
    else {
        const changelogContent = (0, fs_1.readFileSync)(changelogPath, "utf-8");
        const changelogVersionExists = changelogContent.includes(`Version ${rootVersion}`);
        if (!changelogVersionExists) {
            console.warn(`- CHANGELOG.md does not contain Version ${rootVersion} ❌ Please add it.`);
        }
        else {
            console.log(`- CHANGELOG.md contains Version ${rootVersion} ✅`);
        }
    }
};
exports.packageSync = packageSync;
const emptyFolder = (folder) => {
    if (!(0, fs_1.existsSync)(folder))
        return;
    (0, fs_1.readdirSync)(folder).forEach((file) => {
        const curPath = folder + "/" + file;
        if ((0, fs_1.lstatSync)(curPath).isDirectory()) {
            (0, exports.emptyFolder)(curPath);
            (0, fs_1.rmdirSync)(curPath);
        }
        else {
            (0, fs_1.unlinkSync)(curPath);
        }
    });
};
exports.emptyFolder = emptyFolder;
const copyFilesRecursively = (srcDir, destDir, callback) => {
    (0, fs_1.readdir)(srcDir, { withFileTypes: true }, (err, items) => {
        if (err) {
            console.error("Error reading source directory:", err);
            return;
        }
        items.forEach((item) => {
            const srcPath = (0, path_1.join)(srcDir, item.name);
            const destPath = (0, path_1.join)(destDir, item.name);
            if (item.isDirectory()) {
                // Create the directory in the destination and recurse
                (0, fs_1.mkdir)(destPath, { recursive: true }, (err) => {
                    if (err) {
                        console.error(`Error creating directory ${destPath}:`, err);
                    }
                    else {
                        (0, exports.copyFilesRecursively)(srcPath, destPath, callback);
                    }
                });
            }
            else if (item.isFile()) {
                if (destPath.endsWith("manifest.json") && (0, fs_1.existsSync)(destPath)) {
                    const srcText = (0, fs_1.readFileSync)(srcPath, "utf-8");
                    const dstText = (0, fs_1.readFileSync)(destPath, "utf-8");
                    if (srcText !== dstText) {
                        console.log(`\nmanifest.json has changed. Hot Reload will break\n`);
                    }
                }
                // Copy file to the destination directory
                (0, fs_1.copyFileSync)(srcPath, destPath);
                // console.log(`Copied ${srcPath} to ${destPath}`);
            }
        });
        callback && callback();
    });
};
exports.copyFilesRecursively = copyFilesRecursively;
