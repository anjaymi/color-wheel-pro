#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = void 0;
const color = __importStar(require("picocolors"));
const prompts_1 = require("@clack/prompts");
const build_1 = require("./build");
const parse_args_1 = require("./parse-args");
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const quitProcess = (value) => {
    (0, prompts_1.cancel)(value);
    return process.exit(0);
};
const handleCancel = (value) => {
    if ((0, prompts_1.isCancel)(value)) {
        return quitProcess("Operation cancelled");
    }
};
const main = async (initData, overrideArgs = {}) => {
    console.clear();
    // console.log({ base: initData.base });
    const { intro, base, argsTemplate } = initData;
    boltIntro(intro);
    const cliArgs = await (0, parse_args_1.parseArgs)(initData);
    if (process.argv.pop() === "--help") {
        quitProcess("");
    }
    let promptArgs = {};
    for (const arg of argsTemplate) {
        if (typeof cliArgs[arg.name] !== "undefined" ||
            typeof overrideArgs[arg.name] !== "undefined") {
            continue;
        }
        let res;
        if (arg.type === "folder" || arg.type === "string") {
            let completed = false;
            while (!completed) {
                res = (await (0, prompts_1.text)({
                    message: arg.message,
                    initialValue: arg.initialValue,
                    validate: arg.validator,
                }));
                if (arg.type === "folder") {
                    const fullPath = path_1.default.join(process.cwd(), res);
                    if ((0, fs_1.existsSync)(fullPath)) {
                        const overwrite = (await (0, prompts_1.confirm)({
                            message: `⚠️  WARNING: Folder already exists. Do you want to overwite it? ( ${fullPath} )`,
                            initialValue: false,
                        }));
                        if (!overwrite)
                            continue;
                    }
                }
                completed = true;
                handleCancel(res);
            }
        }
        else if (arg.type === "boolean") {
            res = (await (0, prompts_1.confirm)({
                message: arg.message,
                initialValue: arg.initialValue,
            }));
            handleCancel(res);
        }
        else if (arg.type === "select") {
            let completed = false;
            while (!completed) {
                res = (await (0, prompts_1.select)({
                    message: arg.message,
                    options: arg.options,
                }));
                if (arg.validator) {
                    const err = arg.validator([res]);
                    if (err) {
                        prompts_1.log.warn(err);
                        continue;
                    }
                }
                completed = true;
                handleCancel(res);
            }
        }
        else if (arg.type === "multiselect") {
            let completed = false;
            while (!completed) {
                res = (await (0, prompts_1.multiselect)({
                    message: arg.message,
                    options: arg.options,
                    required: arg.required,
                }));
                if (arg.validator) {
                    const err = arg.validator(res);
                    if (err) {
                        prompts_1.log.warn(err);
                        continue;
                    }
                }
                completed = true;
                handleCancel(res);
            }
        }
        if (res) {
            promptArgs[arg.name] = res;
        }
    }
    const finalArgs = { ...cliArgs, ...promptArgs, ...overrideArgs };
    // console.log({
    //   cliArgs,
    //   promptArgs,
    //   finalArgs,
    // });
    await (0, build_1.buildBolt)(intro, initData, base, finalArgs);
    return finalArgs;
};
exports.main = main;
function boltIntro(args) {
    const name = args.name ?? "create-bolt";
    const url = args.url ?? "https://hyperbrew.co";
    const byLine = args.byLine ?? "by Hyper Brew";
    console.log();
    const cbc = color.bgGreen(` ${name} `);
    const urlElement = color.underline(url);
    const bru = color.gray("│   ") + color.cyan(`${byLine} | ${urlElement}`);
    (0, prompts_1.intro)(`${cbc} \n${bru}`);
}
